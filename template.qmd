---
title: Template
author: 
  - name: 山本嵩記 (YAMAMOTO, Takanori)
# date: "`r format(Sys.Date(), '%Y-%m-%d')`"
# date: 2024/10/02
---

# 2024-10-03

## 前回まとめ

見逃していたシミュレーションの確認

S1: 無限個体・条件なしのシミュレーション ([Paper_code_link.java](https://github.com/llamajones24/Inequity-sims)) \< 以降、S1とする。

-   完全に分離した2集団のレプリケーターダイナミクスで戦略を更新

    -   各戦略を相手集団の比率に依存した期待値 (適応度) と集団のその期待値平均との比率で更新。

    -   つまり、集団の平均と比べて良い期待値 (適応度) を持つ戦略の頻度が増加する。

    -   最終的に、収束した慣習をカウントして、どの慣習が生じやすいか集計している。

-   それぞれのグループの各戦略の比率の初期値は、対数を用いた正規化で行っている。

    -   各戦略ごとにランダムで0から1の数値を生成し、それで-logを取っている。

    -   グループごとに合計し、比率をとり、それを初期値としている。

        cf. 前々回までやっていたことは、有限個体・条件つきのABMのシミュレーション

-   [選択肢のバリエーション? と公平性についての研究 \< まずこれかな?]{.underline}

-   グループサイズと公平性についての研究

    -   実験の規模や人集めに、かなりコストが掛かる。 ステレオタイプとの関連は、まだ距離のある話?

以上を受けて...

## 今回の進捗概要

「選択肢のバリエーション? と公平性についての研究」に寄せていく。デフォルトのS1-1では、生産と分配で3\*3の戦略の種類である。この戦略のバリエーションを増やしたい。[生産と分配それぞれ3-10くらいの戦略の種類を持たせたシミュレーションを実装したい。]{.underline}

1.  S1再試完了: S1をC++に書き換え (Javaでも、Rでもいいんだが)。

    -   実行済: 論文で示されたいくつかのパターンの内、利得表で示された2パターン。共に、論文とほぼ同様の結果が得られた。

        -   S1-654-456 (デフォルト): Shirk: 6, Work: 5, Toil: 4 / Low: 4, Med: 5, High: 6

        -   S1-531-357: Shirk: 5, Work: 3, Toil: 1 / Low: 3, Med: 5, High: 7

            -   最も不公平な慣習 (SH, TL) がナッシュ均衡でなくなったパターン

        -   S1-754-457: Shirk: 7, Work: 5, Toil: 3 / Low: 3, Med: 5, High: 7

            -   こちらも、最も不公平な慣習 (SH, TL) に収束しなくなる。

                -   説明については保留: 以下のプログラムができてから行うとする。

2.  進行中: 手軽に2段階の決裂点のある対象ゲームを生成し、利得や均衡解を表示、進化シミュレーションを行うプログラムを作成する。

    -   ゲーム理論のためのRのパッケージ「rgamer」を利用している。

## S1再試完了

C++で書き換えて実行した[^1]。\
現在のファイル場所: /不公平な慣習/simulation/default/replicator_dynamics_simulation_conditionless.cpp

[^1]: 今 (2024-10-02) のところ、Discordのスレッド「#不公平な慣習/S1: 無限個体 (レプリケーター・ダイナミクス)・条件なしシミュレーション」に出力結果を置いている。

シナリオに対するエピソードの数[^2]: 100000000 (10\^8) \< これは論文に倣った。\
エピソードのステップ (ゲームの施行) 数: 1000 \< 適当。もっと小さくても収束しそう (100-200でもOK?)

[^2]: シミュレーションの階層構造やそのおける名称は[@toriumi2014mas]を参考にする。\

| SWT-LMH (利得に対応) | SL-TH (%) | SM-TM (%) | SH-TL (%) | WL-WH (%) | WM-WM (%) |
|----------------------|-----------|-----------|-----------|-----------|-----------|
| ① S1-654-456         | 11.3709   | 33.434    | 18.5575   | 16.6355   | 20.0022   |
| ② S1-531-357         | 22.4944   | 52.3392   | 0         | 4.42281   | 9.05706   |
| ③ S1-754-457         | 22.5833   | 52.3339   | 0         | 4.4259    | 8.99346   |

最も公平な慣習: WM-WM, 最も不公平な慣習: SH-TL

-   ① S1-654-456, ② S1-531-357 は論文の結果とほぼ一致した。

-   ③ S1-754-457は論文に記載の無いのパターン。とりあえず、実行している。なぜ (SH-TL) に収束していないかは、次回説明する。

### ② S1-531-357

これは、最も不公平な慣習 (SH-TL) がナッシュ均衡でないパターン。戦略 (Shirk, H) に対し、最適な反応は同じ戦略 (Shirk, H) であり、戦略 (Toil, L) ではない。新しい均衡は、(Shirk, H)/(Shirk, H) となり、両エージェントはプロジェクトにほとんど投資せず、生産プロジェクトは成立しない。結果、最も不公平な慣習の吸引域はなくなるが、(Shirk, H)/(Shirk, H) に吸引されている (約12%)。

![](images/Screenshot%202024-10-02%20at%2016.16.36.png)

### 保留: その他の論文で言及されたパターン

rgamer を用いたシミュレーションのプログラムで、以下のシナリオを再試したい。

> (DeepL 雑訳) ペイオフ空間を完全に掃引することは現実的ではないが、複製者ダイナミクスのもとで我々の発見の頑健性を検証するために、様々なペイオフをシミュレートした。特に、[努力コストに対する生産財の価値を変化]{.underline}させる。共同生産物の価値が増加するにつれて（努力コストを固定した場合）、公平性の引き寄せの流域は増加し、不公平性の引き寄せの流域は減少する。しかし、その変化は小さく、不公平がより起こりやすい結果であることに変わりはない¹⁹。当然のことながら、[価値の低い共同財は、すべてのプレーヤーが何かを生産するよりも怠けることを好む均衡をもたらす。]{.underline}また、分割要求の特定の選択が結果に影響を与えるかどうかも調べた。その結果、[要求の高低が大きいほど、公平性の吸引域の幅がわずかに大きくなることがわかった。]{.underline}例えば、利用可能な需要が共同財の10％、50％、90％である場合、衡平性の吸引域は40％である。対照的に、可能な要求が財の45％、50％、55％である場合、衡平な結果に達する確率は28％である。これは、ある種の不公平な戦略ペア（例えば、Shirk, H/Toil, L）は、分割要求がばらばらである場合、ナッシュ均衡ではなく、実現可能な慣習²⁰として除外されるためである²⁰。これらのペイオフを変化させても、その影響は軽微であることがわかる。これらのシミュレーションのすべてにおいて、エクイティの魅力が44％を超えることはない。このように、我々は、不公平な規約は、広範囲のペイオフに対して起こりうる結果であると疑う理由がある。

## rgamerを用いたシミュレーションプログラムを作成中

/不公平な慣習/sandbox/done/game_with_disagree_point.R

-   「対称ゲーム」を楽に定義、生成できるようにした。

-   必要に応じて「決裂点」を定義、生成できるようにした。

-   楽に利得表のプロット、純粋・混合戦略を求めることができる (rgamerの機能)。

    -   備え付けのシミュレーションも一応できる (どういう戦略更新かちょっとよくわかってない)。

/不公平な慣習/sandbox/combined_game.R

-   2段階ゲームの利得と期待値の計算をさせたい。

S1デフォルトでC++だと2.5時間掛かる (Number of strategy initializations: 10\^8, Number of plays for each set of initial: 1000)[^3]。実は、Javaの方が早いのだが、並列でシミュレーションさせた場合はC++の方が速そう。Rでゲームとレプリケーターダイナミクスのパラメーターを生成した後に、C++で実装するつもり。もう1週間の作業時間は要りそう。(美しく作ろうとしてロスが多い)

[^3]: Javaの元のプログラムは、2集団に対して別の関数を用いて計算しているのだが、書き換えたC++は同じ関数をいちいち初期化させているから計算が増えている?
